alse see：
    https://wowpedia.fandom.com/wiki/Secure_code
    https://wowpedia.fandom.com/wiki/Category:API_functions/Protected
    https://wowpedia.fandom.com/wiki/Secure_Execution_and_Tainting
    https://wowpedia.fandom.com/wiki/Category:API_functions/Protected
    https://wowpedia.fandom.com/wiki/Category:API_functions/Protected
    https://www.townlong-yak.com/bugs/PfF9rr-UIDropDownMenu
    https://www.townlong-yak.com/taint.log/about.html


Secure code
安全代码：
安全代码拥有调用受保护功能/函数（Protected Functions）的特殊权限。所有的暴雪代码都是安全的，除非它被非安全代码污染(通常通过钩子)。从暴雪的安全框体模板创建的框体也是安全的。

说明：上面提到的钩子，其实更多指的是参数的传递。例如使用了被污染的实参或通过前钩的方式更改输入参数，都会污染暴雪的代码。其它方式也会污染代码，比如对直接对暴雪的全局变量赋值、直接调用暴雪的全局函数。
这里暴雪的模板和安全模板是不同的，一个只是普通的Templates，另一个是SecureTemplates。创建的安全模板可以允许使用一些受保护功能，而创建的普通模板因为污染被禁止调用受保护功能。

、
Protected Functions
受保护功能/函数
这部分API函数受到保护。被用于四种主要类型的函数：
1、插件（或任何其他不安全代码）永远不能调用的API函数。
2、插件（或任何其他不安全代码）无法在战斗中调用的API函数。
3、插件只能调用源自硬件事件（即用户单击按钮），而不能源自OnUpdate/OnEvent处理程序的API函数。
4、仅当应用于同样受保护的框体或组件时才受到保护的API函数。


Secure Execution and Tainting
安全执行和污染
用户界面API从不安全或污染的使用中保护一些功能来授权玩家的决策（human decision-making，这里指代的是游戏中的动作，例如释放技能），特别是在战斗中。这种安全模式主要在2.0的补丁中引入，并且从那时起一直是API的基石。

说明：原则上除了暴雪的代码都是污染代码，本身无论如何都无法运行受保护功能的。但用户界面API提供了一部分内容，让玩家可以调用受保护功能。例如从安全模板中创建的按钮可以通过点击（响应硬件事件）施放技能。


Taint
污染
当《魔兽世界》开始执行Lua代码时，执行（execution ）是从“安全（secure）”开始，并且能够在所有情况下运行受保护功能。执行会一直保持安全，直到遇到“污点（taint）”——这表明函数或对象来自不受信任的地方（插件或脚本——addon或/script）。基本思想是，一旦读取第三方引入的数据或代码，执行就会“被污染（tainted）”，并且任何已经被污染的执行写入的新数据也会被污染。如果插件将污染传播到重要的游戏功能，它将阻止它们工作（尤其是在战斗中）。在玩家重新登录或重载界面之前，污染会一直存在，这可能会造成严重的后果，因为如果受保护的功能检测到潜在的不安全执行路径，它们将会拒绝运行。
当UI首次加载时，来自暴雪签名的FrameXML和插件（以及它们保存的变量）的所有代码和数据都是安全的，并且来自第三方插件（以及他们保存的变量）的所有代码都是受到污染的。

说明：这里值得注意的是执行（execution ）。污染大体分为两类，一个是污染变量，另一个是污染执行。当执行被污染，通常是指调用某个函数的过程被污染。而照成执行污染的原因是引入了受污染的数据或代码。在调用被污染的执行的过程中，所有写入的变量都是被污染的。这整个过程也就是执行路径被污染。


What can be tainted?
什么可以被污染？
所有Lua值和引用都可以被污染——局部变量、全局变量、表键、表值：
1、当新变量被创建（例如local x = 2），它们将继承其执行路径的当前污染。
2、当代码访问安全的值时，结果变量将被当前路径污染（但原始变量的值保持干净）。
3、当代码访问被污染的值时，结果值将保持被污染，执行路径也被污染。
4、当代码设置全局变量时，结果值具有执行路径的污染。
函数闭包也可以被污染，执行函数闭包会将其污染引用到当前环境。

说明：这里的第三条也说明了，当一个函数fun(arg)，如果代码调用函数fun从而访问并传入了被污染的参数arg，函数fun的执行路径也被污染。也就是说函数fun中写入的所有变量都是被污染的。


Securely post-hooking
安全后钩
污染是第三方插件固有的，但API提供了两个强大的功能来避免将污染传播到受保护的游戏功能：
hooksecurefunc(["table"], "name", func) ：插件可以后钩（post-hook）一个安全的全局函数，插入自己的自定义函数，在原始函数之后执行。它接收与原始参数相同的参数的副本，但放在后面执行以防止污染原始参数。
frame:HookScript("handler", func) ：与SetScript()类似，但自定义函数只在其函数之后执行；同样接收相同的参数，但不会将污染传播到已经完成的部分。

说明：安全后钩表示，在不会污染传入参数的情况下钩住你需要的函数，这自然也不会污染被钩住的函数执行，但你自己的代码部分是被污染的。


Protected frames and secure templates
受保护的框体和安全模板
《魔兽世界》2.0还引入了新的Frame概念，受保护框体（protected frames），还可以在战斗中绕过交互限制。但是，需要注意的是，这些必须在脱离战斗时使用预定义的属性创建和预编程。战斗开始后，游戏将根据之前设置的任何属性管理显示、隐藏、调整大小和定义框架。这些属性允许一些逻辑，但仅限于确保实际玩家参与的一些狭义规则。尽管如此，安全代码是一种特殊情况，可以绕过这些限制，在战斗中获得额外（但仍然有限）的功能。
一旦一个框体被声明为受保护，它就不能被取消保护，保护通常是从专门设计的模板继承的，例如SecureTemplates（2.0补丁中引入的基本功能）和SecureHandlers（3.0补丁中引入的扩展功能）。
对受保护框架的控制限制也适用于他们的父框体和他们锚定到的任何框体。这在受保护的框体锚定到另一个通常不受保护的框体时很重要，因为它可能导致意外且不受欢迎的行为。这种传播是暂时的，在战斗之外重新锚定或重新设置框体可以解除限制。
受保护的框体很重要，因为它们构成了暴雪的行动和施法按钮的基础，还因为它们允许一些新的安全按钮模板。由于普通的插件代码被污染，它不能直接改变目标或执行动作，但是《魔兽世界》2.0包含许多可以被插件代码继承的安全模板。这些安全模板提供了一个或多个安全处理程序，通常是OnClick,它们使用框体属性来执行操作。当一个安全模板被继承时，它定义的任何处理程序都保持安全，除非它们被继承框体（或另一个模板）覆盖。
使用与每个模板相关的frame:SetAttribute()方法配置安全模板，但仅限于战斗之外。在创建安全框体、设置其属性或重新配置其属性之前，插件应该检查InCombatLockdown()


Terminology
术语
由于这里有许多类似的概念，一些术语可能会令人困惑，以下是常用术语及其含义的摘要：
1、安全通常意味着“没有污染”。
2、安全代码是指未受污染的当前执行或未受污染的函数。
3、值/引用/参数有时被称为“干净”，这表示与“安全”相同。
4、受保护函数是一种只能从安全执行状态成功调用的函数。
5、受保护框体是在战斗中锁定的框架。
6、受保护的方法（method）是一种无法在战斗期间从受污染的执行状态成功调用受保护框体的方法。
7、安全模板只是定义安全脚本处理程序的XML模板，它们通常还创建受保护的框体。


Impact on gameplay
对游戏的影响
从补丁2.0开始，安全执行极大地限制了插件可以做什么，并且被广泛认为是保护游戏玩法免受作弊所必需的。在此安全模式之前，插件能够通过选择目标对象和施放法术来极大地自动化游戏玩法。例如，以前插件可以在左键单击后选择施放法术（以及该法术的等级）。自补丁2.0起，此插件可以在左键单击后施放一个法术，在右键单击后施放另一个法术，但玩家必须决定单击哪个按钮。插件仍然可以向玩家提供施法建议（通过在屏幕上显示信息），但不能代表玩家做出任何决定。
魔兽世界：怀旧服》使用当前的API，包括安全执行和污染。因此，插件无法在怀旧服中执行在香草年代中实现的破坏游戏的自动化。


Common remarks
常用备注
污染产生的错误需要插件、下拉菜单和其他FrameXML代码的特定迭代，但可以通过修改这些元素中的一个或多个来避免。在通常情况下，修改插件代码就足够了，而在其他情况下，可以对下拉菜单或不安全的FrameXML代码进行修补，从而减轻特定代码路径中的错误。
可能存在还没有提到的有问题的交互。对于这种情况，用一个可靠的测试用例来重现错误可以帮助你识别问题。
虽然可以使用实现类似功能的自定义代码替换插件中的所有下拉菜单用法，但只有当插件不与使用下拉菜单的FrameXML的任何其他部分交互时，这才是完整的解决方案，例如界面选项框体（interface options frame）



参考：https://www.townlong-yak.com/bugs/afKy4k-GetSelectedIDTaint
UIDropDownMenu_GetSelectedID taints dropdown initialization
UIDropDownMenu_GetSelectedID 污染下拉菜单初始化
如果一个插件最近使用了下拉菜单初始化，并且如果正在初始化的下拉菜单还没有选定名称，但确实有一个与其第一个条目不对应的选定值，那调用UIDropDownMenu_Initialize可能会污染当前执行路径，
你可以尝试通过在插件中包含以下代码来解决UIDropDownMenu_GetSelectedID问题


securecall

路径的污染通常会通过全局变量进行传递。
执行的污染是普遍存在的，但只要控制在小范围内就是可以接受的。但只要有一个污染出口就会扩散。这个出口通常是暴雪的全局变量，例如UIDROPDOWNMENU_MENU_VALUE和ACTIVE_CHAT_EDIT_BOX。虽然这个出口我们只污染了变量，但你不知道其它函数如果以这个变量为参数，会照成什么结果。
我们在初始化下拉菜单或调用一些函数的时候无意之中污染了某个全局变量，而其它安全代码调用了这个全局变量，导致污染的扩散，之后又进一步的扩散。直到形成某个函数的闭环，也就是说这个被污染的执行路径中的没有东西再被安全代码调用了。

污染的扩散可以用熵增的方式来理解。污染会随着游戏的运行，不断的扩散，从有序的污染向无序发展。

说明：在tab中污染了执行，之后调用FriendsFrame_OnShow()导致整个界面被污染。